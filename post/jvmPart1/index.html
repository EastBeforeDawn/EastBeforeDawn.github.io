
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>JVM上篇 | 东方未明</title>
<meta name="description" content="温故而知新">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://EastBeforeDawn.github.io/favicon.ico?v=1592408014616">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://EastBeforeDawn.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://EastBeforeDawn.github.io">
        <img class="avatar" src="https://EastBeforeDawn.github.io/images/avatar.png?v=1592408014616" alt="" width="32px" height="32px">
      </a>
      <a href="https://EastBeforeDawn.github.io">
        <h1 class="site-title">东方未明</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://EastBeforeDawn.github.io/post-images/jvmPart1.jpg')">
            </div>
          
          <h2 class="post-title">JVM上篇</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-06-11</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://EastBeforeDawn.github.io/tag/kqgzXDB_o/">
                    Java
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <h2 id="jvm内存结构概述">JVM内存结构概述</h2>
<h3 id="整体结构图">整体结构图</h3>
<figure data-type="image" tabindex="1"><img src="https://EastBeforeDawn.github.io/post-images/1591883345936.png" alt="" loading="lazy"></figure>
<h3 id="类加载器和加载过程概述">类加载器和加载过程概述</h3>
<h4 id="类加载器概念">类加载器概念</h4>
<blockquote>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能,这里就是我们经常能见到的Class类。</p>
</blockquote>
<h4 id="类加载子系统作用">类加载子系统作用</h4>
<ul>
<li>类加载子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识- （0xCAFEBABE）</li>
<li>ClassLoader只负责class文件的加载。至于它是否可以运行，则由Execution Engine决定</li>
<li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是class文件中常量池部分的内存映射）</li>
<li>Class对象是存放在堆区的</li>
</ul>
<h4 id="类加载器classloader角色">类加载器ClassLoader角色</h4>
<ul>
<li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例</li>
<li>class file加载到JVM中，被称为DNA元数据模板，放在方法区</li>
<li>在.calss文件 -&gt; JVM -&gt; 最终成为元数据模板，此过程就要一个运输工具（类装载器），扮演一个快递员的角色</li>
</ul>
<h3 id="类加载过程">类加载过程</h3>
<blockquote>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。(验证、准备和解析又统称为连接，为了支持Java语言的运行时绑定，所以解析阶段也可以是在初始化之后进行的。以上顺序都只是说开始的顺序，实际过程中是交叉的混合式进行的，加载过程中可能就已经开始验证了)<br>
<img src="https://EastBeforeDawn.github.io/post-images/1591883779566.png" alt="" loading="lazy"></p>
</blockquote>
<h4 id="一-加载loading">一. 加载（Loading）：</h4>
<ul>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<h5 id="加载-calss-文件的方式">加载 .calss 文件的方式</h5>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络获取，典型场景：Web Applet</li>
<li>从zip压缩文件中读取，成为日后jar、war格式的基础</li>
<li>运行时计算生成，使用最多的是：动态代理技术</li>
<li>由其他文件生成，比如 JSP 应用</li>
<li>从专有数据库提取.class 文件，比较少见</li>
<li>从加密文件中获取，典型的防 Class 文件被反编译的保护措施</li>
</ul>
<h4 id="二-连接linking">二. 连接（Linking）</h4>
<h5 id="1验证verify">1.验证（Verify）</h5>
<ul>
<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li>
<li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证</li>
</ul>
<h5 id="2准备prepare">2.准备（Prepare）</h5>
<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值</li>
<li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化</li>
<li><code>这里不会为实例变量分配初始化</code>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li>
</ul>
<pre><code class="language-java">private static int i = 1;  //变量i在准备阶只会被赋值为0，初始化时才会被赋值为1
private final static int j = 2;  //这里被final修饰的变量j，直接成为常量，编译时就会被分配为2
</code></pre>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>int</th>
<th>long</th>
<th>short</th>
<th>char</th>
<th>byte</th>
<th>boolean</th>
<th>float</th>
<th>double</th>
<th>reference</th>
</tr>
</thead>
<tbody>
<tr>
<td>零值</td>
<td>0</td>
<td>0L</td>
<td>(short)0</td>
<td>'\u0000'</td>
<td>(byte)0</td>
<td>false</td>
<td>0.0f</td>
<td>0.0d</td>
<td>null</td>
</tr>
</tbody>
</table>
<h5 id="3解析resolve">3.解析（Resolve）</h5>
<ul>
<li>将常量池内的符号引用转换为直接引用的过程</li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等</li>
</ul>
<h4 id="三-初始化initialization">三. 初始化（Initialization）</h4>
<ul>
<li><code>初始化阶段就是执行类构造器方法</code>&lt;clinit&gt;()<code>的过程</code></li>
<li>此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</li>
<li>构造器方法中指令按语句在源文件中出现的<code>顺序执行</code></li>
<li>&lt;clinit&gt;()不同于类的构造器（构造器是虚拟机视角下的&lt;linit&gt;）</li>
<li>若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕</li>
<li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁</li>
</ul>
<h5 id="顺序执行的字节码文件示例">顺序执行的字节码文件示例</h5>
<pre><code>package com.atguigu;

public class ClazzInit {
    public static int mun = 1;
    static {
        mun = 2;
        number = 10;
    }
    public static int number = 20;

    public static void main(String[] args) {

    }
}
</code></pre>
<p><strong>clint字节码文件</strong></p>
<pre><code class="language-tex"> 0 iconst_1
 1 putstatic #2 &lt;com/atguigu/ClazzInit.mun&gt;
 4 iconst_2
 5 putstatic #2 &lt;com/atguigu/ClazzInit.mun&gt;
 8 bipush 10
10 putstatic #3 &lt;com/atguigu/ClazzInit.number&gt;
13 bipush 20
15 putstatic #3 &lt;com/atguigu/ClazzInit.number&gt;
18 return
</code></pre>
<p>可以明显看出number先赋值为10，在赋值为20</p>
<h5 id="代码错误示例">代码错误示例</h5>
<pre><code>package com.atguigu;

public class ClazzInit {
    public static int mun = 1;
    static {
        mun = 2;
        number = 10;
        System.out.println(number); //非法的前向引用
    }
    public static int number = 20;

    public static void main(String[] args) {

    }
}
</code></pre>
<h5 id="注意事项">注意事项</h5>
<ul>
<li>如果一个类没有静态变量或者静态代码块，这个类不会生成&lt;clinit&gt;()方法</li>
</ul>
<pre><code>package com.atguigu;

public class ClazzInit {
    public  int mun = 1;
    public static void main(String[] args) {

    }
}
</code></pre>
<p><strong>字节码文件截图</strong><br>
<img src="https://EastBeforeDawn.github.io/post-images/1591884212469.png" alt="" loading="lazy"></p>
<h5 id="多线程类加载加锁示例">多线程类加载加锁示例</h5>
<pre><code>package com.atguigu;

public class ClazzInit {
    static class DeadClazz{
        static {
            if(true) {
                System.out.println(Thread.currentThread().getName() + &quot;DeadClazz类正在加载&quot;);
                while (true) {

                }
            }
        }
    }
    public static void main(String[] args) {
        Runnable runnable = () -&gt; {
            DeadClazz deadClazz = new DeadClazz();
        };
        Thread t1 = new Thread(runnable);
        Thread t2 = new Thread(runnable);
        t1.start();
        t2.start();
    }
}
</code></pre>
<p>会输出一个线程正在加载，另外一个线程一直等待</p>
<h3 id="类加载器">类加载器</h3>
<blockquote>
<ul>
<li>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</li>
<li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将**<code>所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</code>**</li>
</ul>
</blockquote>
<p><code>注意:下图中三个已经实现的加载器不是继承关系</code><br>
<img src="https://EastBeforeDawn.github.io/post-images/1591884228613.png" alt="" loading="lazy"></p>
<h4 id="启动类加载器引导类加载器bootstrap-classloader">启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4>
<ul>
<li>这个类加载使用C/C++ 语言实现，嵌套在JVM 内部</li>
<li>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resource.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li>
<li>并不继承自 java.lang.ClassLoader，没有父加载器</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li>
<li>出于安全考虑，Boostrap 启动类加载器只加载名为java、Javax、sun等开头的类</li>
</ul>
<h4 id="扩展类加载器extension-classloader">扩展类加载器（Extension ClassLoader）</h4>
<ul>
<li>java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li>
<li>派生于 ClassLoader</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext 子目录（扩展目录）下加载类库。如果用户创建的JAR 放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
<h4 id="应用程序类加载器也叫系统类加载器appclassloader">应用程序类加载器（也叫系统类加载器，AppClassLoader）</h4>
<ul>
<li>java语言编写，由 sun.misc.Lanucher$AppClassLoader 实现</li>
<li>派生于 ClassLoader</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</li>
<li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载的</li>
<li>通过 ClassLoader#getSystemClassLoader() 方法可以获取到该类加载器</li>
</ul>
<h4 id="类加载器代码示例">类加载器代码示例</h4>
<pre><code class="language-java">public class ClassLoaderTest {
    public static void main(String[] args) {
        //获取系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@135fbaa4

        //获取其上层：扩展类加载器
        ClassLoader extClassLoader = systemClassLoader.getParent();
        System.out.println(extClassLoader);  //sun.misc.Launcher$ExtClassLoader@2503dbd3

        //再获取其上层：获取不到引导类加载器
        ClassLoader bootstrapClassLoader = extClassLoader.getParent();
        System.out.println(bootstrapClassLoader);     //null

        //对于用户自定义类来说，默认使用系统类加载器进行加载，输出和systemClassLoader一样
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        System.out.println(classLoader);  //sun.misc.Launcher$AppClassLoader@135fbaa4

        //String 类使用引导类加载器进行加载。Java的核心类库都使用引导类加载器进行加载，所以也获取不到
        ClassLoader classLoader1 = String.class.getClassLoader();
        System.out.println(classLoader1);  //null

        //获取BootstrapClassLoader可以加载的api的路径
        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
        for (URL url : urls) {
            System.out.println(url.toExternalForm());
        }
    }
}
</code></pre>
<p><strong>结果</strong></p>
<pre><code>sun.misc.Launcher$AppClassLoader@18b4aac2
sun.misc.Launcher$ExtClassLoader@61bbe9ba
null
sun.misc.Launcher$AppClassLoader@18b4aac2
null
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/resources.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/sunrsasign.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/jsse.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/jce.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/charsets.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/jfr.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/classes
</code></pre>
<h4 id="用户自定义类加载器">用户自定义类加载器</h4>
<blockquote>
<p>在Java的日常应用程序开发中，类的加载几乎是由3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式</p>
</blockquote>
<h5 id="为什么要自定义类加载器">为什么要自定义类加载器？</h5>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源（可以从数据库、云端等指定来源加载类）</li>
<li>防止源码泄露（Java代码容易被反编译，如果加密后，自定义加载器加载类的时候就可以先解密，再加载）</li>
</ul>
<h5 id="用户自定义加载器实现步骤">用户自定义加载器实现步骤</h5>
<ul>
<li>开发人员可以通过继承抽象类 java.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是JDK1.2之后已经不建议用户去覆盖loadClass()方式，而是建议把自定义的类加载逻辑写在findClass()方法中</li>
<li>编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ul>
<h5 id="classloader常用方法">ClassLoader常用方法</h5>
<blockquote>
<p>ClassLoader类，是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>getParent()</td>
<td>返回该类加载器的超类加载器</td>
</tr>
<tr>
<td>loadClass(String name)</td>
<td>加载名称为name的类，返回java.lang.Class类的实例</td>
</tr>
<tr>
<td>findClass(String name)</td>
<td>查找名称为name的类，返回java.lang.Class类的实例</td>
</tr>
<tr>
<td>findLoadedClass(String name)</td>
<td>查找名称为name的已经被加载过的类，返回java.lang.Class类的实例</td>
</tr>
<tr>
<td>defineClass(String name, byte[] b, int off, int len)</td>
<td>把字节数组b中内容转换为一个Java类，返回java.lang.Class类的实例</td>
</tr>
<tr>
<td>resolveClass(Class&lt;?&gt; c)</td>
<td>连接指定的一个Java类</td>
</tr>
</tbody>
</table>
<h5 id="获取classloader的途径">获取ClassLoader的途径</h5>
<ul>
<li>获得当前类的ClassLoader
<ul>
<li>clazz.getClassLoader()</li>
</ul>
</li>
<li>获得当前线程上下文的ClassLoader
<ul>
<li>Thread.currentThread().getContextClassLoader()</li>
</ul>
</li>
<li>获取系统的ClassLoader
<ul>
<li>ClassLoader.getSystemClassLoader()</li>
</ul>
</li>
<li>获取调用者的ClassLoader</li>
<li>DriverManager.getCallerClassLoader();</li>
</ul>
<h4 id="双亲委派机制">双亲委派机制</h4>
<blockquote>
<p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类的时候才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交给父类处理，它是一种任务委派模式。<br>
<img src="https://EastBeforeDawn.github.io/post-images/1591884247393.png" alt="" loading="lazy"></p>
</blockquote>
<h5 id="工作过程">工作过程</h5>
<ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</li>
</ol>
<h5 id="优势">优势</h5>
<ul>
<li>
<p>避免类的重复加载，JVM中区分不同类，不仅仅是根据类名，相同的class文件被不同的ClassLoader加载就属于两个不同的类（比如，Java中的Object类，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，如果不采用双亲委派模型，由各个类加载器自己去加载的话，系统中会存在多种不同的Object类）</p>
</li>
<li>
<p>保护程序安全，防止核心API被随意篡改，避免用户自己编写的类动态替换 Java的一些核心类，比如我们自定义类：java.lang.String</p>
</li>
</ul>
<p><strong><code>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</code></strong></p>
<ul>
<li>类的完成类名必须一致，包括包名</li>
<li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</li>
</ul>
<h5 id="代码示例1">代码示例1</h5>
<pre><code class="language-java">package java.lang;

public class String {
    
    public static void main(String[] args) {
        System.out.println(&quot;我说自定义String类&quot;);
    }
}
</code></pre>
<p><strong>结果</strong></p>
<pre><code>错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
否则 JavaFX 应用程序类必须扩展javafx.application.Application
</code></pre>
<h5 id="代码示例2">代码示例2</h5>
<p>在java包下新建类</p>
<pre><code>package java.atguigu;

public class ClazzLoaderTest {
    public static void main(String[] args) {
        String s = new String();
    }
}
</code></pre>
<p><strong>结果</strong></p>
<pre><code class="language-tex">Error: A JNI error has occurred, please check your installation and try again
Exception in thread &quot;main&quot; java.lang.SecurityException: Prohibited package name: java.atguigu
	at java.lang.ClassLoader.preDefineClass(ClassLoader.java:655)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:754)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:468)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:74)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:369)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:363)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:362)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:418)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:355)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:351)
	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)
</code></pre>
<h5 id="沙箱安全机制">沙箱安全机制</h5>
<blockquote>
<p>如果我们自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样就可以保证对java核心源代码的保护，这就是简单的沙箱安全机制。</p>
</blockquote>
<h5 id="破坏双亲委派模型">破坏双亲委派模型</h5>
<blockquote>
<p>双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式，可以“被破坏”，只要我们自定义类加载器，重写loadClass()方法，指定新的加载逻辑就破坏了，重写findClass()方法不会破坏双亲委派。</p>
</blockquote>
<blockquote>
<p>双亲委派模型有一个问题：顶层ClassLoader，无法加载底层ClassLoader的类。典型例子JNDI、JDBC，所以加入了线程上下文类加载器（Thread Context ClassLoader）,可以通过Thread.setContextClassLoaser()设置该类加载器，然后顶层ClassLoader再使用Thread.getContextClassLoader()获得底层的ClassLoader进行加载。</p>
</blockquote>
<blockquote>
<p>Tomcat中使用了自定ClassLoader，并且也破坏了双亲委托机制。每个应用使用WebAppClassloader进行单独加载，他首先使用WebAppClassloader进行类加载，如果加载不了再委托父加载器去加载，这样可以保证每个应用中的类不冲突。每个tomcat中可以部署多个项目，每个项目中存在很多相同的class文件（很多相同的jar包），他们加载到jvm中可以做到互不干扰。</p>
</blockquote>
<blockquote>
<p>利用破坏双亲委派来实现代码热替换（每次修改类文件，不需要重启服务）。因为一个Class只能被一个ClassLoader加载一次，否则会报java.lang.LinkageError。当我们想要实现代码热部署时，可以每次都new一个自定义的ClassLoader来加载新的Class文件。JSP的实现动态修改就是使用此特性实现。</p>
</blockquote>
<h5 id="类的主动使用和被动使用">类的主动使用和被动使用</h5>
<p>Java程序对类的使用方式分为：主动使用和被动使用。虚拟机规范规定有且只有7种情况必须立即对类进行“初始化”，即类的主动使用。</p>
<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法（即遇到new、getstatic、putstatic、invokestatic这四条字节码指令时）</li>
<li>反射</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK7 开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果，REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li>
</ul>
<p>除以上7种情况，其他使用Java类的方式被看作是对类的被动使用，都不会导致类的初始化。</p>
<p><strong>代码示例</strong></p>
<pre><code>public class NotInitialization {
    public static void main(String[] args) { 
        //只输出SupperClass int 123,不会输出SubClass init
        //对于静态字段，只有直接定义这个字段的类才会被初始化
        System.out.println(SubClass.value); 
    }
}

class SuperClass {
    static {
        System.out.println(&quot;SupperClass init&quot;);
    }
    public static int value = 123;
}

class SubClass extends SuperClass {
    static {
        System.out.println(&quot;SubClass init&quot;);
    }
}
</code></pre>
<h2 id="运行时数据区的内存结构">运行时数据区的内存结构</h2>
<blockquote>
<p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行<br>
JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行<br>
不同的JVM对于内存的划分方式和管理机制存在着部分差异</p>
</blockquote>
<p><img src="https://EastBeforeDawn.github.io/post-images/1591884267919.png" alt="" loading="lazy"><br>
<img src="https://EastBeforeDawn.github.io/post-images/1591884274422.png" alt="" loading="lazy"></p>
<p><strong>线程</strong></p>
<ul>
<li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。</li>
<li>在HotspotJVM里，每个线程都与操作系统的本地线程直接映射
<ul>
<li>当一个Java线程准备好执行以后， 此时一个操作系统的本地线程也同时创建。Java线程执行终止以后，本地线程也会回收。</li>
</ul>
</li>
<li>操作系统负责所有都线程安排调度到任何一个可用的CPU上，一旦本地线程初始化成功，就会调用Java线程的run方法</li>
</ul>
<h3 id="1program-counter-register-程序计数寄存器">1.Program Counter Register (程序计数寄存器)</h3>
<blockquote>
<p>Register 的命名源于CPU的寄存器，CPU只有把数据装载到寄存器才能够运行</p>
</blockquote>
<blockquote>
<p>寄存器存储指令相关的现场信息，由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。这样必然导致经常中断或恢复，如何保证分毫无差呢?</p>
</blockquote>
<blockquote>
<p>每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器用来存放执行指令的偏移量和行号指示器等，线程执行或恢复都要依赖程序计数器。程序计数器在各个线程之间互不影响，此区域也不会发生内存溢出异常。</p>
</blockquote>
<blockquote>
<p><strong><code>这里并非广义上的物理寄存器，它是对PC物理寄存器的一种抽象的模拟</code></strong></p>
</blockquote>
<h4 id="定义">定义</h4>
<ul>
<li>程序计数器是一块较小的内存空间，可看作当前线程正在执行的字节码的行号指示器</li>
<li>如果当前线程正在执行的是
<ul>
<li>Java方法 ,计数器记录的就是当前线程正在执行的字节码指令的地址</li>
<li>本地方法,那么程序计数器值为undefined</li>
</ul>
</li>
</ul>
<h4 id="作用">作用</h4>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ul>
<h4 id="特点">特点</h4>
<ul>
<li>一块较小的内存空间</li>
<li>线程私有。每条线程都有一个独立的程序计数器。</li>
<li>是唯一一个不会出现OOM的内存区域。</li>
<li>生命周期随着线程的创建而创建，随着线程的结束而死亡。</li>
</ul>
<h5 id="代码示例">代码示例</h5>
<pre><code>package com.atguigu;

public class ClazzLoaderTest {
    public static void main(String[] args) {
        int a = 0;
        int b = 0;
        System.out.println(a);
    }
}
</code></pre>
<p><strong>字节码</strong></p>
<pre><code class="language-tex">//第一列为指令地址
//第二列为操作指令 
 0 iconst_0
 1 istore_1
 2 iconst_0
 3 istore_2
 4 getstatic #2 &lt;java/lang/System.out&gt;
 7 iload_1
 8 invokevirtual #3 &lt;java/io/PrintStream.println&gt;
11 return
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://EastBeforeDawn.github.io/post-images/1591884292118.png" alt="" loading="lazy"></figure>
<h3 id="2-java虚拟机栈jvm-stack">2. Java虚拟机栈(JVM Stack)</h3>
<blockquote>
<p>由于跨平台性的设计， Java的指令都是根据栈来设计的。不同平台的CPU架构不同，所以不能设计成基于寄存器的。<br>
优点是跨平台,指令集小,编译器容易实现,缺点是性能下降,实现同样 的功能需要更多的指令。</p>
</blockquote>
<h4 id="定义-2">定义</h4>
<ul>
<li>java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。相对于基于寄存器的运行环境来说，JVM是基于栈结构的运行环境。栈结构移植性更好，可控性更强。JVM中的虚拟机栈是描述Java方法执行的内存区域。</li>
<li>栈中的元素用于支持虚拟机进行方法调用，每个方法从开始调用到执行完成的过程，就是栈帧从入栈到出栈的过程。</li>
<li>它保存方法的局部变量、8种基本数据类型、对象的引用地址、部分结果，并参与方法的调用和返回。</li>
</ul>
<h4 id="特点-2">特点</h4>
<ul>
<li>Java虚拟机栈也是线程私有的</li>
<li>随着线程的创建而创建,随着线程的死亡而死亡.</li>
</ul>
<h4 id="会出现的异常">会出现的异常</h4>
<p>Java虚拟机规范中规定：<code>java栈的大小是动态的或者是固定不变的</code></p>
<h5 id="stackoverflowerror">StackOverFlowError</h5>
<ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量，java虚拟机将会抛出一个 StackOverFlowError异常</li>
</ul>
<h5 id="outofmemoryerror">OutOfMemoryError</h5>
<ul>
<li>如果java虚拟机栈可以动态拓展，并且在尝试拓展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个 OutOfMemoryError异常</li>
</ul>
<h4 id="设置栈的大小-xss">设置栈的大小 -Xss</h4>
<ul>
<li>-Xss=1M</li>
<li>-Xss=1024k</li>
</ul>
<h4 id="栈的存储原理">栈的存储原理</h4>
<h5 id="栈中储存什么">栈中储存什么</h5>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以栈帧 (Stack Frame)的格式存在。</li>
<li>在这个线程正在执行的每个方法都各自对应一个栈帧 (Stack Frame)。</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li>
</ul>
<h5 id="栈运行原理">栈运行原理</h5>
<ul>
<li>JVM直接接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出” / “后进先出”原则。</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧 (Current Frame)，与当前栈帧相对应的方法就是”当前方法（Current Method)，定义这个方法的类就是当前类(Current Class)</li>
<li>在执行引擎运行时，所有指令都只能针对当前栈帧进行操作</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前桢。</li>
</ul>
<hr>
<ul>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li>
<li>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</li>
</ul>
<h4 id="栈的内部结构">栈的内部结构</h4>
<blockquote>
<p>每个栈帧中存储有：</p>
</blockquote>
<ul>
<li><code>局部变量表(Local Variables)</code></li>
<li><code>操作数栈 (Operand Stack)(或表达式栈)</code></li>
<li>动态链接 (Dynamic Linking)(或指向运行时常量池的方法引用)</li>
<li>方法返回地址(Return Address)(或方法正常退出或者异常退出的定义)</li>
<li>一些附加信息<br>
<img src="https://EastBeforeDawn.github.io/post-images/1591884307067.png" alt="" loading="lazy"></li>
</ul>
<h4 id="1局部变量表local-variables">1.局部变量表(Local Variables)</h4>
<ul>
<li>局部变量表也被称之为局部变量数组或本地变量表</li>
<li>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用 (reference)，以及returnAddress 类型。</li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</li>
<li>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的 Code 属性的 maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li>
</ul>
<h5 id="slot的理解">slot的理解</h5>
<ul>
<li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</li>
<li>局部变量表，最基本的存储单位是slot (变量槽)</li>
<li>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型(reference) , returnAddress类型。</li>
<li>在局部变量表中，32位以内的类型只占1个slot (包括returnAddress类型) ，64位的类型（long和double)占两个slot
<ul>
<li>byte 、short 、char 在存储前被转换为 int， boolean 也被转换为int，0 表示false，非0表示true。</li>
<li>long 和double 则占据两个slot。</li>
</ul>
</li>
</ul>
<pre><code class="language-tex">public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3（表示三个局部变量）, args_size=1
         0: iconst_0
         1: istore_1
         2: iconst_0
         3: istore_2
         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         7: iload_1
         8: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
        11: return
      LineNumberTable:
        line 5: 0
        line 6: 2
        line 7: 4
        line 8: 11
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      12     0  args   [Ljava/lang/String;  // 第一个
            2      10     1     a   I           //第二个
            4       8     2     b   I           // 第三个
}
</code></pre>
<ul>
<li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li>
<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<code>按照顺序</code>被复制到局部变量表中的每一个Slot上</li>
<li><code>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。</code>（比如：访问long或double类型变量）</li>
<li>如果当前帧是由构造方法或者实例方法创建的，那么<code>该对象引用this将会存放在index为0的slot处</code>，其余的参数按照参数表顺序继续排列</li>
</ul>
<h5 id="slot的重复利用">slot的重复利用</h5>
<ul>
<li>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的 新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。<br>
<img src="https://EastBeforeDawn.github.io/post-images/1591884320390.png" alt="" loading="lazy"></li>
<li>图中index为2的索引出现两次，是因为变量c在代码块中，作用域只有4行，在局部变量表的数组里已经开辟了空间，定义变量b的时候重新利用的c的空间</li>
</ul>
<h5 id="静态变量与局部变量的对比">静态变量与局部变量的对比</h5>
<ul>
<li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配</li>
<li>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li>
<li>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li>
</ul>
<pre><code class="language-java">public class ClazzLoaderTest {
    public static void main(String[] args) {
        int a ;
       // System.out.println(a); 变量未进行初始化
    }
}
</code></pre>
<h5 id="补充说明">补充说明</h5>
<ul>
<li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>
<li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都会被回收。</li>
</ul>
<h4 id="2操作数栈-operand-stack">2.操作数栈 (Operand Stack)</h4>
<ul>
<li>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-Out)的操作数栈，也可以称之为表达式栈(Expression Stack)</li>
<li>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈( push) /出栈(pop)。
<ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。</li>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>操作数栈，<code>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</code></li>
<li>操作数栈就是JVM执行引擎的下一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之创建出来，<code>这个方法的操作数栈是空的</code></li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_statck的值</li>
<li>栈中的任何一个元素都是可以任意的Java数据类型；32bit的类型占用一个栈单位深度，64bit的类型占用两个栈单位的深度</li>
<li>操作数栈<code>并非采用访问索引的方式来进行数据访问的</code>，而是只能通过标准的入栈和出栈操作完成一次数据访问</li>
<li><code>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</code>，并更新PC寄存器中下一条需要执行的字节码指令</li>
<li>操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次检验</li>
<li>另外，我们说Java虚拟机的<code>解释引擎是基于栈的执行引擎</code>，其中栈指的就是操作数栈</li>
</ul>
<h5 id="代码示例-2">代码示例</h5>
<pre><code>public void testOperation() {

		byte i = 15;
		int j = 8;
		int k = i + j;

	}
</code></pre>
<p><strong>使用javap命令反编译class文件：javap -v 类名.class</strong></p>
<pre><code class="language-tex"> public void testOperation();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=4, args_size=1
         0: bipush        15
         2: istore_1
         3: bipush        8
         5: istore_2
         6: iload_1
         7: iload_2
         8: iadd
         9: istore_3
        10: return
</code></pre>
<p><strong>执行过程</strong><br>
<img src="https://EastBeforeDawn.github.io/post-images/1591884337130.png" alt="" loading="lazy"><br>
<img src="https://EastBeforeDawn.github.io/post-images/1591884340418.png" alt="" loading="lazy"><br>
<img src="https://EastBeforeDawn.github.io/post-images/1591884344946.png" alt="" loading="lazy"><br>
<img src="https://EastBeforeDawn.github.io/post-images/1591884348959.png" alt="" loading="lazy"></p>
<h5 id="栈顶缓存top-of-stack-cashing技术">栈顶缓存（Top-of-Stack Cashing）技术</h5>
<ul>
<li>基于栈式架构的虚拟机所使用的的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈和指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数</li>
<li>由于操作数栈式存储在内存中的，因此频繁的执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，<code>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</code></li>
</ul>
<h4 id="3动态链接">3.动态链接</h4>
<ul>
<li>每一个栈帧内部都包含一个指向*<code>运行时常量池</code>*中<code>该栈帧所属方法的引用</code>。包含这个引用的目的就是为了支持当前方法的代码能够实现<code>动态链接(Dynamic Linking)</code>。比如：invokedynamic指令</li>
<li>Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如，描述一个方法调用另外的其他方法时，就是通过常量池中的指向方法的符号引用来表示的，那么<code>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</code><br>
<img src="https://EastBeforeDawn.github.io/post-images/1591884375832.png" alt="" loading="lazy"></li>
</ul>
<h5 id="方法的调用">方法的调用</h5>
<p><strong>静态链接与动态链接</strong></p>
<blockquote>
<p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。</p>
</blockquote>
<ul>
<li>静态链接：
<ul>
<li>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</li>
</ul>
</li>
<li>动态链接：
<ul>
<li>如果<code>被调用的方法在编译期无法被确定下来</code>，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种转换过程具备动态性，因此也就被称之为动态链接。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>早期绑定与晚期绑定</strong></p>
<blockquote>
<p>对应的方法的绑定机制为：早期绑定（Early Binding)和晚期绑定(Late Binding)。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
</blockquote>
<ul>
<li>早期绑定：
<ul>
<li>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，将这个方法与所属的类型进行绑定，这样一来，由于十分明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
</ul>
</li>
<li>晚期绑定：
<ul>
<li>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">package com.atguigu.java2;

/**
 * 说明早期绑定和晚期绑定的例子
 * @author shkstart
 * @create 2020 上午 11:59
 */
class Animal{

    public void eat(){
        System.out.println(&quot;动物进食&quot;);
    }
}
interface Huntable{
    void hunt();
}
class Dog extends Animal implements Huntable{
    @Override
    public void eat() {
        System.out.println(&quot;狗吃骨头&quot;);
    }

    @Override
    public void hunt() {
        System.out.println(&quot;捕食耗子，多管闲事&quot;);
    }
}

class Cat extends Animal implements Huntable{

    public Cat(){
        super();//表现为：早期绑定
    }

    public Cat(String name){
        this();//表现为：早期绑定
    }

    @Override
    public void eat() {
        super.eat();//表现为：早期绑定
        System.out.println(&quot;猫吃鱼&quot;);
    }

    @Override
    public void hunt() {
        System.out.println(&quot;捕食耗子，天经地义&quot;);
    }
}
public class AnimalTest {
    public void showAnimal(Animal animal){
        animal.eat();//表现为：晚期绑定
    }
    public void showHunt(Huntable h){
        h.hunt();//表现为：晚期绑定
    }
}
</code></pre>
<ul>
<li>随着高级语言的横空出世，类似于Java一样的基于面对对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面对对象的特性，既然这一类的编程语言具备多态特性，那么自然也就具备了早期绑定和晚期绑定两种绑定方式。</li>
<li>Java中任何一个普通的方法其实都具有虚函数的特性，它们相当于C++语言中的虚函数（ C++中则需要使用关键字 virtual来显式定义）。如果在 Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</li>
</ul>
<hr>
<p><strong>虚方法与非虚方法</strong></p>
<ul>
<li>非虚方法：
<ul>
<li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法称为非虚方法</li>
<li>静态方法，私有方法，final方法，实例构造器，父类方法都是非虚方法</li>
</ul>
</li>
<li>其他方法都是虚方法</li>
</ul>
<h5 id="方法调用指令">方法调用指令</h5>
<ul>
<li>普通调用指令
<ul>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial: 调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有的虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ul>
</li>
<li>动态调用指令
<ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法的版本，其中<code>invokespecial和invokestatic调用的方法称为非虚方法，其余的（final修饰除外）称为虚方法</code></p>
<pre><code class="language-java"> 
 package com.atguigu.java2;

/**
 * 解析调用中非虚方法、虚方法的测试
 *
 * invokestatic指令和invokespecial指令调用的方法称为非虚方法
 * @author shkstart
 * @create 2020 下午 12:07
 */
class Father {
    public Father() {
        System.out.println(&quot;father的构造器&quot;);
    }

    public static void showStatic(String str) {
        System.out.println(&quot;father &quot; + str);
    }

    public final void showFinal() {
        System.out.println(&quot;father show final&quot;);
    }

    public void showCommon() {
        System.out.println(&quot;father 普通方法&quot;);
    }
}

public class Son extends Father {
    public Son() {
        //invokespecial
        super();
    }
    public Son(int age) {
        //invokespecial
        this();
    }
    //不是重写的父类的静态方法，因为静态方法不能被重写！
    public static void showStatic(String str) {
        System.out.println(&quot;son &quot; + str);
    }
    private void showPrivate(String str) {
        System.out.println(&quot;son private&quot; + str);
    }

    public void show() {
        //invokestatic
        showStatic(&quot;atguigu.com&quot;);
        //invokestatic
        super.showStatic(&quot;good!&quot;);
        //invokespecial
        showPrivate(&quot;hello!&quot;);
        //invokespecial
        super.showCommon();

        //invokevirtual
        showFinal();//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。
        //虚方法如下：
        //invokevirtual
        showCommon();
        info();

        MethodInterface in = null;
        //invokeinterface
        in.methodA();
    }

    public void info(){

    }

    public void display(Father f){
        f.showCommon();
    }

    public static void main(String[] args) {
        Son so = new Son();
        so.show();
    }
}

interface MethodInterface{
    void methodA();
}
</code></pre>
<p><strong>关于invokedynamic指令</strong></p>
<ul>
<li>JVM字节码指令集一直比较稳定，Java7中才增加了一个invokedynamic指令，这其实是<code>Java实现[动态类型语言]的一种改进</code></li>
<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</li>
<li>Java7中增加的动态语言类型支持的本质是对Java虛拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li>
</ul>
<pre><code>package com.atguigu;

/**
 * 体会invokedynamic指令
 * @author shkstart
 * @create 2020 下午 3:09
 */
@FunctionalInterface
interface Func {
    public boolean func(String str);
}

public class Lambda {
    public void lambda(Func func) {
        return;
    }

    public static void main(String[] args) {
        Lambda lambda = new Lambda();

        Func func = s -&gt; {
            return true;
        };

        lambda.lambda(func);

        lambda.lambda(s -&gt; {
            return true;
        });
    }
}
</code></pre>
<p>lambda表达式的引入一定程度上具备了动态语言的特点</p>
<pre><code class="language-tex"> 0 new #2 &lt;com/atguigu/Lambda&gt;
 3 dup
 4 invokespecial #3 &lt;com/atguigu/Lambda.&lt;init&gt;&gt;
 7 astore_1
 8 invokedynamic #4 &lt;func, BootstrapMethods #0&gt;
13 astore_2
14 aload_1
15 aload_2
16 invokevirtual #5 &lt;com/atguigu/Lambda.lambda&gt;
19 aload_1
20 invokedynamic #6 &lt;func, BootstrapMethods #1&gt;
25 invokevirtual #5 &lt;com/atguigu/Lambda.lambda&gt;
28 return
</code></pre>
<p><strong>动态类型语言和静态类型语言</strong></p>
<blockquote>
<p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言</p>
</blockquote>
<ul>
<li>静态类型语言是判断变量自身的类型信息。</li>
<li>动态类型语言是判断变量值的类型信息。</li>
<li>变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要的特征</li>
<li>Java是静态类型语言 ，String s = &quot;123&quot;;</li>
<li>JS是动态类型语言，var s = 123;</li>
</ul>
<p><strong>Java语言中方法重写的本质：</strong></p>
<ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型 C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，査找过程结束；如果不通过，则返回java. lang. IllegalAccessError 异常。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
<p><strong>IllegalAccessError 介绍：</strong></p>
<ul>
<li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般<br>
的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的<br>
改变。</li>
</ul>
<h5 id="虚方法表">虚方法表</h5>
<ul>
<li>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表(virtual method table)(非虚方法不会出现在表中）来实现。使用索引表來代替查找。</li>
<li>每个类中都有一个虛方法表，表中存放有各个方法的实际入口。</li>
<li>那么虚方法表什么时候被创建？
<ul>
<li>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初阶段准备完成之后，JVM会把该类的方法表也初始化完毕。</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://EastBeforeDawn.github.io/post-images/1591884395949.png" alt="" loading="lazy"></figure>
<h4 id="4方法返回地址">4.方法返回地址</h4>
<blockquote>
<p>存放调用该方法的pc寄存器的值</p>
</blockquote>
<ul>
<li>一个方法的结束有两种方式
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>无论哪种方式退出，在方法退出后都返回到该方法被调用的位置，方法正常退出时，<code>调用者的pc计数器的值作为返回地址</code>，即调用该方法的指令的下一条指令的地址。而异常退出，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息<br>
<img src="https://EastBeforeDawn.github.io/post-images/1591884452836.png" alt="" loading="lazy"></li>
</ul>
<blockquote>
<p>本质上，方法的退出就是当前栈帧出栈的过程，此时，需要恢复上层方的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。<br>
正常完成出口和异常完成出口的区別在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p>
</blockquote>
<blockquote>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
</blockquote>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令（return) 会有返回值传递给上层的方让调用者，简称正常完成出口;</li>
</ol>
<ul>
<li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含 ireturn (当返回值是 boolean、 byte、 char、short和 int类型时使用）、 lreturn、 freturn、 dreturn以及 areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</li>
</ul>
<ol start="2">
<li>在方法执行的过程中遇到了异常（Exception)，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。</li>
</ol>
<ul>
<li>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</li>
</ul>
<h4 id="5一些附加信息">5.一些附加信息</h4>
<blockquote>
<p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息</p>
</blockquote>
<h4 id="java栈面试题">Java栈面试题</h4>
<h4 id="方法定义的局部变量是否是线程安全"># 方法定义的局部变量是否是线程安全</h4>
<ul>
<li>具体情况具体分析</li>
</ul>
<pre><code class="language-java">package com.atguigu.java3;

/**
 * 面试题：
 * 方法中定义的局部变量是否线程安全？具体情况具体分析
 *
 *   何为线程安全？
 *      如果只有一个线程才可以操作此数据，则必是线程安全的。
 *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。
 * @author shkstart
 * @create 2020 下午 7:48
 */
public class StringBuilderTest {

    int num = 10;

    //s1的声明方式是线程安全的
    public static void method1(){
        //StringBuilder:线程不安全
        StringBuilder s1 = new StringBuilder();
        s1.append(&quot;a&quot;);
        s1.append(&quot;b&quot;);
        //...
    }
    //sBuilder的操作过程：是线程不安全的
    public static void method2(StringBuilder sBuilder){
        sBuilder.append(&quot;a&quot;);
        sBuilder.append(&quot;b&quot;);
        //...
    }
    //s1的操作：是线程不安全的
    public static StringBuilder method3(){
        StringBuilder s1 = new StringBuilder();
        s1.append(&quot;a&quot;);
        s1.append(&quot;b&quot;);
        return s1;
    }
    //s1的操作：是线程安全的
    public static String method4(){
        StringBuilder s1 = new StringBuilder();
        s1.append(&quot;a&quot;);
        s1.append(&quot;b&quot;);
        return s1.toString();
    }

    public static void main(String[] args) {
        StringBuilder s = new StringBuilder();


        new Thread(() -&gt; {
            s.append(&quot;a&quot;);
            s.append(&quot;b&quot;);
        }).start();

        method2(s);

    }

}
</code></pre>
<h3 id="3本地方法栈">3.本地方法栈</h3>
<h4 id="学在前面本地方法接口">学在前面：本地方法接口</h4>
<blockquote>
<p>简单地讲，一个Native Method就是一个Java调用非Java代码的借口。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern &quot;C&quot;告知C++编译器去调用一个C的函数。I<br>
&quot;A native method is a Java method whose implementation is provided by non-java code.&quot;<br>
在定义一个native method时，并不提供实现体（有些像定义一个Java interface)，因为其实现体是由非java语言在外面实现的<br>
本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序</p>
</blockquote>
<h5 id="为什么要使用natice-method">为什么要使用Natice Method</h5>
<blockquote>
<p>Java使用起来非常方便，然而有些层次的任务用Java实现起来小容易，或者我们对程序的效率很在意时，问题就来了。</p>
</blockquote>
<ul>
<li>与Java环境外交互
<ul>
<li>有时Java应用想要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样的一种交流机制：它为我们提供了一个个非常简洁的接口而且我们不用去了解Java应用之外的繁琐的细节。</li>
</ul>
</li>
</ul>
<h4 id="本地方法栈">本地方法栈</h4>
<ul>
<li>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</li>
<li>本地方法栈，也是线程私有的。</li>
<li>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面时相同的）
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会<br>
抛出一个 Stack〇verflowError 异常</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。</li>
</ul>
</li>
<li>本地方法是使用C语言实现的</li>
<li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。</li>
</ul>
<h5 id="本地方法栈运行时状态">本地方法栈运行时状态</h5>
<blockquote>
<p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不在受虚拟机限制的世界。它和虚拟机拥有同样的权限</p>
</blockquote>
<ul>
<li>本地方法可以通过本地方法接口来访问虚拟也机内部的运行时数据区。</li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存。</li>
</ul>
<p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果jvm产品不打算支持native方法，也可以无需实现本地方法栈。<br>
在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p>
<h3 id="4堆heap">4.堆(heap)</h3>
<h4 id="核心概述">核心概述</h4>
<ul>
<li>
<p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>
</li>
<li>
<p>Java堆区在 JVM启动的时候即被创建，其空间大小也就确定了。是 JVM管理的最大一块内存空间。</p>
<ul>
<li>堆内存的大小是可以调节的。</li>
</ul>
</li>
<li>
<p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>
</li>
<li>
<p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer, TLAB) 。</p>
</li>
</ul>
<hr>
<ul>
<li>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应在运行时分配在堆上。 (The heap is the run-time data area from which memory for all class instances and arrays is allocated ):
<ul>
<li><code>“几乎”</code>所有的对象实例都在这里分配内存。从实际使用角度看的。</li>
</ul>
</li>
<li>数组和对象可能永远不会存储在栈上，因力栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li>
<li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</li>
<li>堆，是GC ( Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</li>
</ul>
<h4 id="内存细分">内存细分</h4>
<blockquote>
<p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间可以细分</p>
</blockquote>
<h5 id="java-7及之前">Java 7及之前</h5>
<ul>
<li>堆内存逻辑上分为三部分：新生区+养老区+<code>永久区</code>
<ul>
<li>Young Generation Space 新生区    Young/New
<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space 养老区 Old/Tenure</li>
<li>Permanent Space 永久区                Perm</li>
</ul>
</li>
</ul>
<h5 id="java-8及之后">Java 8及之后</h5>
<ul>
<li>堆内存逻辑上分为三部分:新生区+养老区+<code>元空间</code>
<ul>
<li>Young Generation Space 新生区 Young/New
<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
</ul>
</li>
<li>Tenure generation space 养老区 Old/Tenure</li>
<li>Meta Space 元空间 Meta</li>
</ul>
<h5 id="年轻代与老年代">年轻代与老年代</h5>
<ul>
<li>存储在JVM中的Java对象可以被划分为两类：
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</li>
</ul>
</li>
<li>Java堆区进一步细分的话，可以划分为年轻代（YoungGen)和老年代（OldGen)</li>
<li>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）。</li>
</ul>
<hr>
<ul>
<li>配置新生代与老年代在堆结构的占比。
<ul>
<li>默认- XX: NewRatio=2,表示新生代占1,老年代占2,新生代占整个堆的1/3</li>
<li>可以修改-XX: NewRatio=4,表示新生代占1,老年代占4,新生代占整个堆的 1/5</li>
</ul>
</li>
<li>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8 :1:1</li>
<li>当然开发人员可以通选项 “-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio=8
<ul>
<li>几乎所有的 Java对象都是在Eden区被new出来的。</li>
</ul>
</li>
<li>绝大部分的 Java对象的销毁都在新生代进行了。</li>
<li>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</li>
<li>可以以使用选项&quot;-Xmn&quot;设置新生代最大内存大小
<ul>
<li>这个参数一般使用默认值就可以了。</li>
</ul>
</li>
</ul>
<h4 id="堆空间大小的设置">堆空间大小的设置</h4>
<ul>
<li>
<p>Java堆用来储存对象堆实例，那么Java堆的大小在启动时就设定好了，可以通过选项&quot;-Xmx&quot;和&quot;-Xms&quot;来进行设置。</p>
<ul>
<li>“-Xms&quot;用于表示堆区的起始内存，等价于-XX: InitialHeapSize</li>
<li>“-Xmx&quot;则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li>
</ul>
</li>
<li>
<p>一旦堆区中的内存大小超过“-Xmx&quot;所指定的最大内存时，将会抛出 OutOfMemoryError异常</p>
</li>
<li>
<p>通常会将 -Xms和 - Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收器清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</p>
<ul>
<li>默认情况下，初始内存大小：物理电脑内存大小/ 64</li>
</ul>
</li>
<li>
<p>最大内存大小：物理电脑内存大小/ 4</p>
</li>
</ul>
<h4 id="对象分配过程概述">对象分配过程概述</h4>
<blockquote>
<p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
</blockquote>
<ol>
<li>new 的对象先放在伊甸园区，此区有大小限制</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC),将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</li>
<li>然后将伊甸园中的剩余对象移动到幸存者0区。</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会到幸存者1区。</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>
<li>啥时候能去养老区呢？可以设罝次数。默认是15次。</li>
</ol>
<ul>
<li>可以设置参数：-XX:MaxTenuringThreshold=<N>进行设置</li>
</ul>
<ol start="7">
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC: Major GC,进行养老区的内存清理。</li>
<li>若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生00M异常</li>
</ol>
<ul>
<li>java.lang.OutOfMemoryError: Java heap space</li>
</ul>
<h5 id="总结">总结</h5>
<ul>
<li>针对幸存者 S0,Sl区的总结：复制之后有交换，谁空谁是to.</li>
<li>关于垃圾回设：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集</li>
</ul>
<h4 id="minor-gc-major-gc-和full-gc">Minor GC ，Major GC 和Full GC</h4>
<blockquote>
<p>JVM在进行GC时，并非每次都对面三个内存（新生代、老年代、方法区)区域一起回收的，大部分时候回收的都是指新生代。<br>
针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC), —种是整堆收集（Full GC)</p>
</blockquote>
<h5 id="部分收集">部分收集</h5>
<p>部分收集：不是完整的收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li>新生代收收集（Minor GC / Young GC)：只是新生代的垃圾收集</li>
<li>老年代收集（Major GC / Old GC)：只有老年代的垃圾收集
<ul>
<li>目前只有CMS GC会有单独收集老年代的行为</li>
<li>注意，很多时候Major GC会 和Full GC浞淆使用，具体要分辨是老年代回收还是整堆回收。</li>
</ul>
</li>
<li>混合收集（Mixed GC):收集整个新生代以及部分老年代的垃圾收集。
<ul>
<li>目前，只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
<h5 id="整堆收集">整堆收集</h5>
<p>整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集</p>
<h5 id="年轻代-gcminor-gc触发机制">年轻代 GC(Minor GC)触发机制</h5>
<ul>
<li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</li>
<li>因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>
<li>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。<br>
<img src="./1591863057157.png" alt="Alt text" loading="lazy"></li>
</ul>
<h5 id="老年代gc-major-gcfull-gc触发机制">老年代GC (Major GC/Full GC)触发机制：</h5>
<ul>
<li>指发生在老年代的GC,对象从老年代消失时，我们说“Major GC” 或“Full GC“发生了。</li>
<li>出现了Major GC，经常会伴随至少一次的Minor GC (但非绝对的，在ParallelScavenge收集器的收集策略就有直接进行Major GC的策略选择过程)
<ul>
<li>也就足在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足则触发Major GC</li>
</ul>
</li>
<li>Major GC的速度一般会比Minor GC慢40倍以上，STW的时间更长。</li>
<li>如果Major GC后，内存还不足，就报00M了 。</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
<h5 id="fullgc触发机制">FullGC触发机制</h5>
<p>FullGC执行的情况如下五种</p>
<ul>
<li>调用System.gc()时，系统建议执行Full GC,但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、survivor0 (From Space)区向survivor1(ToSpace) 区复制时，对象大小大于To Space的可用内存，则把该对象转到老年代，且老年代的可用内存小于该对象大小</li>
</ul>
<p>** 说明：full gc是开发或调优中尽量要避免的。这样暂停的时间会短一些 **</p>
<h4 id="堆分代收集思想">堆分代收集思想</h4>
<p>为什么需要把Jaya堆分代?不分代就不能正常工作了吗?<br>
经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<ul>
<li>新生代：有Eden、两块大小相同的Survivor(又称为from/to， s0/s1) 构成，to总为空。</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象。</li>
</ul>
<p>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>

          </div>
        </div>

        
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">温故而知新</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://EastBeforeDawn.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '9961657e440c6c52cf9e',
        clientSecret: '7a480d1c774328434dcd5cf1f5feefa9f0e91583',
        repo: 'EastBeforeDawn.github.io',
        owner: 'EastBeforeDawn',
        admin: ['EastBeforeDawn'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
